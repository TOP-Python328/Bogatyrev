ШАБЛОНЫ ПРОЕКТИРОВАНИЯ, ЧАСТЬ 2

  ==========  1  ==========  

В файле chess.py находится реализация ООП модели основных сущностей для игры шахматы. 
Диаграмма классов модели в файле chess.png

Внимательно изучите код и взаимиодействие объектов между собой.

Реализуйте класс-хранитель Turn.

    В нём должна сохраняться информация:
      — о фигуре, сделавшей ход
      — о клетке, с которой был сделан ход
      — о клетке, на которую был сделан ход.

Реализуйте класс Game, который будет совмещать функции инициатора и опекуна.

    С помощью этого класса у вас должны быть возможности: 
      — управлять экземпляром игровой доски
      — совершать ходы с клетки на клетку
      — хранить историю ходов
      — выводить все записанные ходы, нумерованные с единицы
      — возвращаться к началу заданного хода.

Классы Turn и Game должны быть согласованы с существующей объектной моделью.

Можно использовать импорт из файла chess.py



  ==========  2  ==========

Снова обратимся к шахматам из задачи 1.

Перепроектируйте модель и перепишите код таким образом, чтобы для каждого вида фигуры была реализована стратегия корректного в рамках шахматных правил хода.

    https://ru.wikipedia.org/wiki/Шахматы#Ходы

Масштабируйте вашу модель двумя стратегиями строкового представления фигур:
  
  1) с помощью буквенных международных обозначений
        https://ru.wikipedia.org/wiki/Шахматная_нотация#Именование_фигур
  
  2) с помощью символов шахматных фигур из UTF-8
        ♔ ♕ ♖ ♗ ♘ ♙ ♚ ♛ ♜ ♝ ♞ ♟
        (символы хорошо выглядят в шрифтах DejaVu Sans, FreeSerif и Quivira)

Добавьте в настройки игры (класс Game) возможность переключаться между стратегиями вывода.



  ==========  3  ==========

У вас есть веб-сервер, принимающий и обрабатывающий запросы. Каждый запрос после обработки получает ответ с определённым кодом. 
Этот ответ должен пройти цепочку обработчиков, каждый из которых реагирует только на один определённый код. 

Напишите класс, имитирующий получение веб-сервером запросов (например, из stdin) и генерацию ответов с кодами (например: 200, 403, 404, 500). 
Ответ может быть кортежем, словарём, отдельным классом или любой другой структурой данных — главное, чтобы одним из элементов этой структуры был код ответа.

Напишите классы-обработчики в количестве, соответствующем числу генерируемых вариантов кодов ответа.

Каждый обработчик должен проверять код ответа. 
Если код в ответе не соответствует коду конкретного обработчика, то обработчик ничего не делает с ответом, а передаёт объект ответа дальше (работа цепочки продолжается). 
Если код в ответе эквивалентен коду конкретного обработчика, то обработчик должен обозначить свою реакцию (например, сообщением в stdout, содержащим имя класса обработчика) и НЕ должен передавать объект дальше (работа цепочки останавливается).

Самостоятельно выберите способ реализации: цепочка методов или брокер событий.



  =========================

Каждый класс должен быть документирован. 
Каждый метод кроме встроенных (специальных) должен быть документирован.

Каждое поле класса должно быть аннотировано. 
Атрибуты экземпляра аннотируются в том случае, если типы их значений не совпадают с соответствующими переданными в конструктор аргументами, или если атрибуты создаются безотносительно переданных в конструктор аргументов.
Каждый параметр (кроме self и cls) всех методов должен быть аннотирован. 
Каждое возвращаемое значение методов кроме встроенных (специальных) должно быть аннотировано.

Во всех случаях аннотация опускается, если с аннотируемым идентификатором может быть связан объект произвольного типа.

Помимо перечисленных в каждой задаче обязательных атрибутов классов и экземпляров возможно добавление собственных вспомогательных атрибутов и методов.

Работа классов тестируется в режиме инспекции файла с кодом.
Ввод и вывод в стандартные потоки результатов тестов копируются.
Копия в виде комментария помещается в конец файла с кодом задачи.

Невыполнение дополнительных задач не повлечёт снижения баллов за задание. Тем не менее они настоятельно рекомендуются к решению.

В сервис Журнал отправляется сообщение о выполнении всех частей задания со ссылкой на репозиторий.

Преподаватель пишет комментарии и правки в коде задач и обновляет файлы в удалённом репозитории.
Регулярно получайте обновления в свой локальный репозиторий из удалённого репозитория.